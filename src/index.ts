import fsp from 'node:fs/promises'
import path from 'node:path'
import { dset } from 'dset'
import { type MarkedExtension, marked } from 'marked'
import { markedTerminal } from 'marked-terminal'
import { merge } from 'ts-deepmerge'
import { createLogger, type LogLevel, type Plugin } from 'vite'
import {
  assertExistence,
  enumerateLangs,
  findAll,
  jsNormalizedLang,
  loadAndParse,
  resolvedVirtualModuleId,
  resolvePaths,
  virtualModuleId,
} from './utils.js'

marked.use(markedTerminal() as MarkedExtension)

// unfortunately not exported
export const LogLevels: Record<LogLevel, number> = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3,
}

export interface Options {
  /**
   * Set to 'info' for noisy information.
   *
   * Default: 'warn'
   */
  logLevel?: LogLevel

  /**
   * Glob patterns to match files
   *
   * Default: ['**\/*.json', '**\/*.yml', '**\/*.yaml']
   */
  include?: string[]

  /**
   * Glob patterns to exclude/ignore
   *
   */
  ignore?: string | string[]

  /**
   * Locale top level directory paths ordered from least specialized to most specialized
   *  e.g. lib locale -> app locale
   *
   * Locales loaded later will overwrite any duplicated key via a deep merge strategy.
   */
  paths: string[]

  /**
   * Default: none
   */
  namespaceResolution?: 'basename' | 'relativePath'

  /**
   * Path to output TypeScript type definitions file
   *
   * When specified, the plugin will generate a .d.ts file with type definitions
   * for the language resources instead of runtime values.
   */
  typeOutputPath?: string

  /**
   * Language to use for TypeScript type generation
   *
   * When typeOutputPath is specified, this determines which language's
   * literal values will be used for the type definitions. This enables
   * type-safe i18next usage with proper key checking and return types.
   *
   * Default: first language found
   */
  typeLanguage?: string
}

export interface ResBundle {
  [key: string]: string | object
}

// for fast match on hot reloading check?
let loadedFiles: string[] = []
let allLangs = new Set<string>()

function generateTypeDefinitions(
  appResBundle: ResBundle,
  allLangs: Set<string>,
  typeLanguage?: string,
): string {
  // Determine which language to use for type generation
  const targetLang = typeLanguage || Array.from(allLangs)[0]

  if (!targetLang || !appResBundle[targetLang]) {
    throw new Error(
      `Language '${targetLang}' not found in resource bundle. Available languages: ${Array.from(allLangs).join(', ')}`,
    )
  }

  return `/* eslint-disable */
// biome-ignore-all lint assist: Ignore generated file

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by vite-plugin-i18next-loader.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

export type Resources = ${JSON.stringify(appResBundle[targetLang], null, 2)}
`
}

const factory = (options: Options) => {
  const log = createLogger(options.logLevel || 'warn', {
    prefix: '[i18next-loader]',
  })

  function loadLocales() {
    const localeDirs = resolvePaths(options.paths, process.cwd())
    assertExistence(localeDirs)

    let appResBundle: ResBundle = {}
    loadedFiles = [] // reset
    allLangs = new Set<string>() // reset

    log.info('Bundling locales (ordered least specific to most):', {
      timestamp: true,
    })

    localeDirs.forEach((nextLocaleDir) => {
      const langs = enumerateLangs(nextLocaleDir)
      langs.forEach((lang) => allLangs.add(lang))

      for (const lang of langs) {
        const langDir = path.join(nextLocaleDir, lang)
        const langFiles = findAll(
          options.include || ['**/*.json', '**/*.yml', '**/*.yaml'],
          langDir,
          options.ignore,
        )

        for (const langFile of langFiles) {
          loadedFiles.push(langFile)
          log.info(`\t${langFile}`, {
            timestamp: true,
          })

          const content = loadAndParse(langFile)
          const resourceToMerge: ResBundle = {}

          if (options.namespaceResolution) {
            let namespaceFilepath: string = langFile
            if (options.namespaceResolution === 'relativePath') {
              namespaceFilepath = path.relative(
                path.join(nextLocaleDir, lang),
                langFile,
              )
            } else if (options.namespaceResolution === 'basename') {
              namespaceFilepath = path.basename(langFile)
            }
            const extname = path.extname(langFile)
            const namespaceParts = namespaceFilepath
              .replace(extname, '')
              .split(path.sep)
            dset(resourceToMerge, [lang, ...namespaceParts].join('.'), content)
          } else {
            resourceToMerge[lang] = content
          }
          appResBundle = merge(appResBundle, resourceToMerge)
        }
      }
    })

    // one bundle - works, no issues with dashes in names
    // const bundle = `export default ${JSON.stringify(appResBundle)}`

    // named exports, requires manipulation of names
    let namedBundle = ''
    for (const lang of allLangs) {
      namedBundle += `export const ${jsNormalizedLang(lang)} = ${JSON.stringify(
        appResBundle[lang],
      )}\n`
    }
    let defaultExport = 'const resources = { \n'
    for (const lang of allLangs) {
      defaultExport += `"${lang}": ${jsNormalizedLang(lang)},\n`
    }
    defaultExport += '}'
    defaultExport += '\nexport default resources\n'

    const bundle = namedBundle + defaultExport

    log.info(`Locales module '${resolvedVirtualModuleId}':`, {
      timestamp: true,
    })

    // emulate log.info for our marked terminal output
    if (LogLevels[options.logLevel || 'warn'] >= LogLevels['info']) {
      // eslint-disable-next-line no-console
      console.log(
        marked(`
\`\`\`js
${bundle}
\`\`\`
`),
      )
    }

    return appResBundle
  }

  async function generateAndWriteTypes(
    appResBundle: ResBundle,
    allLangs: Set<string>,
  ) {
    if (!options.typeOutputPath) return

    const typeDefinitions = generateTypeDefinitions(
      appResBundle,
      allLangs,
      options.typeLanguage,
    )

    // Ensure the directory exists
    const typeOutputDir = path.dirname(options.typeOutputPath)
    try {
      await fsp.mkdir(typeOutputDir, { recursive: true })
    } catch (error) {
      // mkdir with recursive: true should not throw EEXIST, but let's be safe
      const nodeError = error as NodeJS.ErrnoException
      if (nodeError.code !== 'EEXIST') {
        throw error
      }
    }

    try {
      await fsp.writeFile(options.typeOutputPath, typeDefinitions)
      log.info(`Generated TypeScript types at: ${options.typeOutputPath}`, {
        timestamp: true,
      })
    } catch (error) {
      log.error(`Failed to write TypeScript types: ${(error as Error).message}`)
      throw error
    }
  }

  function generateBundle(
    appResBundle: ResBundle,
    allLangs: Set<string>,
  ): string {
    // named exports, requires manipulation of names
    let namedBundle = ''
    for (const lang of allLangs) {
      namedBundle += `export const ${jsNormalizedLang(lang)} = ${JSON.stringify(
        appResBundle[lang],
      )}\n`
    }
    let defaultExport = 'const resources = { \n'
    for (const lang of allLangs) {
      defaultExport += `"${lang}": ${jsNormalizedLang(lang)},\n`
    }
    defaultExport += '}'
    defaultExport += '\nexport default resources\n'

    return namedBundle + defaultExport
  }

  const plugin: Plugin = {
    name: 'vite-plugin-i18next-loader', // required, will show up in warnings and errors
    resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId
      }
      return null
    },
    async load(id) {
      if (id !== resolvedVirtualModuleId) {
        return null
      }

      const appResBundle = loadLocales()
      const bundle = generateBundle(appResBundle, allLangs)

      log.info(`Locales module '${resolvedVirtualModuleId}':`, {
        timestamp: true,
      })

      // emulate log.info for our marked terminal output
      if (LogLevels[options.logLevel || 'warn'] >= LogLevels['info']) {
        // eslint-disable-next-line no-console
        console.log(
          marked(`
\`\`\`js
${bundle}
\`\`\`
`),
        )
      }

      await generateAndWriteTypes(appResBundle, allLangs)

      for (const file of loadedFiles) {
        this.addWatchFile(file)
      }
      return bundle
    },

    /**
     * Watch translation message files and trigger an update.
     *
     * @see https://github.com/vitejs/vite/pull/10333 <- TODO this is the one that would be easiest and may not be a full reload
     */
    async handleHotUpdate({ file, server }) {
      const isLocaleFile =
        file.match(/\.(json|yml|yaml)$/) &&
        options.paths.some((p) => file.startsWith(path.join(process.cwd(), p)))
      if (isLocaleFile) {
        log.info(`Changed locale file: ${file}`, {
          timestamp: true,
        })

        const { moduleGraph } = server

        const module = moduleGraph.getModuleById(resolvedVirtualModuleId)
        if (module) {
          await server.reloadModule(module)
        }
      }
    },
  }
  return plugin
}

export default factory
