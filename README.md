![MIT](https://img.shields.io/badge/License-MIT-green?style=for-the-badge)
![Version](https://img.shields.io/github/package-json/v/ensdomains/vite-plugin-i18next-loader?style=for-the-badge)
![CI](https://img.shields.io/github/actions/workflow/status/ensdomains/vite-plugin-i18next-loader/build.yml?style=for-the-badge)

# vite-plugin-i18next-loader

```
pnpm add -D @ensdomains/vite-plugin-i18next-loader
```

Vite plugin to client bundle i18next locales composited from one to many json/yaml files _from_ one to many libraries. Zero config HMR support included.

This vite-plugin i18next loader generates the `resources` structure necessary for [i18next](https://github.com/i18next/i18next). The structure is made available as a [virtual module](https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention) to the client bundle at build time, thus avoiding loading any language resources via extra HTTP requests.

## Features

- [x] Glob based file filtering
- [x] One to many overrides supporting reuse cases (locales in library packages/white labeling)
- [x] Yaml and Json support
- [x] HMR hot module reloading

Given a locales directory, by default, the loader will find and parse any `json|yaml|yml` file and attribute the
contents to the containing lang folder e.g. `en`. There is no need to add lang such as `en` or `de` inside your
`json` or `yaml` files.

See the [`test/data` directory](https://github.com/ensdomains/vite-plugin-i18next-loader/tree/main/src/__tests__/data) for structure and example data.

## Usage

### Sample app structure

```
â””â”€â”€ app
    â””â”€â”€ src
    â”‚  â””â”€â”€ index.js
    â””â”€â”€ locales
       â”œâ”€â”€ de
       â”‚   â”œâ”€â”€ foo.json
       â”‚   â””â”€â”€ bar.yaml
       â””â”€â”€ en
           â”œâ”€â”€ foo.json
           â””â”€â”€ bar.yaml
```

### vite.config.ts

```ts
import { defineConfig } from 'vite'
import i18nextLoader from 'vite-plugin-i18next-loader'

export default defineConfig({
  plugins: [i18nextLoader({ paths: ['./node_modules/foo/locales', './locales'] })],
})
```

### app.ts

```typescript
// File: app.ts
import i18n from 'i18next'
import resources from 'virtual:i18next-loader'

i18n.init({
  resources,
})

// Use the resources as documented on i18next.com
i18n.t('key')
```

## TypeScript Type Generation

This plugin can automatically generate TypeScript type definitions for your translation resources, enabling full type safety with i18next as described in the [i18next TypeScript documentation](https://www.i18next.com/overview/typescript).

### Configuration

Add the `typeOutputPath` option to your vite config to enable TypeScript type generation:

```ts
import { defineConfig } from 'vite'
import i18nextLoader from 'vite-plugin-i18next-loader'

export default defineConfig({
  plugins: [
    i18nextLoader({ 
      paths: ['./locales'],
      typeOutputPath: './src/types/i18n.d.ts', // Generate TypeScript definitions
      typeLanguage: 'en' // Use English for type generation (optional)
    })
  ],
})
```

### Usage with i18next TypeScript Support

Once configured, the plugin will generate a TypeScript definition file containing the exact structure and literal values of your translations. You can then use this with i18next's type system:

**Generated file** (`./src/types/i18n.d.ts`):
```ts
/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by vite-plugin-i18next-loader.
// You should NOT make any changes in this file as it will be overwritten.

export type Resources = {
  "common": {
    "hello": "Hello World",
    "welcome": "Welcome to our app"
  },
  "navigation": {
    "home": "Home",
    "about": "About"
  }
}
```

**Type declaration file** (`./src/types/i18next.d.ts`):
```ts
import type { Resources } from './i18n';

declare module 'i18next' {
  interface CustomTypeOptions {
    defaultNS: 'common';
    resources: Resources;
  }
}
```

**Usage in your app**:
```ts
import i18n from 'i18next'
import resources from 'virtual:i18next-loader'

i18n.init({
  resources,
  defaultNS: 'common'
})

// Now you have full type safety!
i18n.t('common:hello') // âœ… TypeScript knows this key exists
i18n.t('common:invalid') // âŒ TypeScript error: key doesn't exist
i18n.t('navigation:home') // âœ… TypeScript knows this key exists

// Return types are also inferred
const greeting: "Hello World" = i18n.t('common:hello') // âœ… Literal type!
```

### TypeScript Options

- **`typeOutputPath`**: Path where the TypeScript definition file will be generated. If not specified, no types will be generated.
- **`typeLanguage`**: Which language to use as the source for type generation. Defaults to the first language found alphabetically. It's recommended to specify your primary language (usually 'en') to ensure consistent type generation.

### Benefits

Using TypeScript type generation provides:

- **ðŸ” IntelliSense**: Full autocomplete for translation keys in your IDE
- **âœ… Compile-time validation**: Catch missing or incorrect translation keys at build time
- **ðŸ·ï¸ Literal types**: Return types match the actual translation values
- **ðŸ”„ Auto-updates**: Types are regenerated when translation files change during development

For more details on i18next TypeScript integration, see the [official i18next TypeScript documentation](https://www.i18next.com/overview/typescript).

## Options

```ts
export interface Options {
  /**
   * Set to 'info' for noisy information.
   *
   * Default: 'warn'
   */
  logLevel?: LogLevel

  /**
   * Glob patterns to match files
   *
   * Default: ['**\/*.json', '**\/*.yml', '**\/*.yaml']
   */
  include?: string[]

  /**
   * Glob patterns to exclude/ignore
   *
   * @see https://github.com/isaacs/node-glob
   */
  ignore?: string | string[] | IgnoreLike

  /**
   * Locale top level directory paths ordered from least specialized to most specialized
   *  e.g. lib locale -> app locale
   *
   * Locales loaded later will overwrite any duplicated key via a deep merge strategy.
   */
  paths: string[]

  /**
   * Default: none
   */
  namespaceResolution?: 'basename' | 'relativePath'

  /**
   * Path to output TypeScript type definitions file
   * 
   * When specified, the plugin will generate a .d.ts file with type definitions
   * for the language resources with literal values for i18next TypeScript support.
   * 
   * Default: undefined (no types generated)
   */
  typeOutputPath?: string

  /**
   * Language to use for TypeScript type generation
   * 
   * When typeOutputPath is specified, this determines which language's
   * literal values will be used for the type definitions. This enables
   * type-safe i18next usage with proper key checking and return types.
   * 
   * Default: first language found alphabetically
   */
  typeLanguage?: string
}
```

### `include` to filtering files read

You can filter files in your file structure by specifying any glob supported by [`glob`](https://github.com/isaacs/node-glob). By default, any `json|yaml|yml` in the `paths` directories will be loaded.

#### Only json

```ts
const options = {
  include: ['**/*.json'],
}
```

#### All json except one file

```ts
const options = {
  include: ['**/*.json'],
  ignore: ['**/excludeThis.json'],
}
```

### `paths` for overriding/white labeling

Applications that reuse libraries e.g. white labeling, can utilize one to many sets of locale directories that
the app will override.

```ts
const options = {
  include: ['../node_modules/lib1/locales', './locales'], // from least to most specialized
}
```

This configures the loader to work on a file structure like the following:

```
â””â”€â”€ app
    â”œâ”€â”€ src
    â”‚  â””â”€â”€ app.js
    â”œâ”€â”€ locales
    â”‚  â””â”€â”€ en
    â”‚      â”œâ”€â”€ foo.json
    â”‚      â””â”€â”€ bar.yaml
    â””â”€â”€ node_modules
        â””â”€â”€ lib1
            â””â”€â”€ locales
               â””â”€â”€ en
                   â”œâ”€â”€ foo.json
                   â””â”€â”€ bar.yaml
```

Everything from `./locales` will override anything specified in one to many libraries.

### `namespaceResolution`

Namespace resolution will impact the structure of the bundle. If you want the files' `basename` or relative path to be injected, look at the following options.

#### `namespaceResolution: 'basename'`

```ts
const options = {
  namespaceResolution: 'basename',
}
```

The following file structure would result in resources loaded as below:

```
â””â”€â”€ app
    â”œâ”€â”€ src
    â”‚  â””â”€â”€ index.js
    â””â”€â”€ locales
       â””â”€â”€ en
           â”œâ”€â”€ foo.json
           â””â”€â”€ bar.yaml
```

foo.json

```json
{
  "header": {
    "title": "TITLE"
  }
}
```

bar.yaml

```yml
footer:
  aboutUs: About us
```

Results in this object loaded:

```json
{
  "en": {
    "foo": {
      "header": {
        "title": "TITLE"
      }
    },
    "bar": {
      "footer": {
        "aboutUs": "About us"
      }
    }
  }
}
```

#### `namespaceResolution: 'relativePath'`

```ts
const options = {
  namespaceResolution: 'relativePath',
}
```

The following file structure would result in resources loaded as below:

```
â””â”€â”€ app
    â””â”€â”€ locales
       â”œâ”€â”€ index.js
       â””â”€â”€ en
           â”œâ”€â”€ green.yaml
           â””â”€â”€  blue
                â””â”€â”€  foo.yaml
```

green.yaml

```yml
tree:
  species: Oak
```

blue/foo.yaml

```yml
water:
  ocean: Quite large
```

Results in this object loaded:

```json
{
  "en": {
    "green": {
      "tree": {
        "species": "Oak"
      }
    },
    "blue": {
      "foo": {
        "water": {
          "ocean": "Quite large"
        }
      }
    }
  }
}
```

**NOTE:** If you have a file and a folder with the same name, you **MIGHT** overwrite one with the other. For example:

```
â””â”€â”€ app
    â””â”€â”€ locales
       â”œâ”€â”€ index.js
       â””â”€â”€ en
           â”œâ”€â”€ blue.yaml
           â””â”€â”€  blue
                â””â”€â”€  foo.yaml
```

blue.yaml

```yml
foo: Welcome
```

blue/foo.yaml

```yml
eggs: delicious
```

Results in this object loaded:

```json
{
  "en": {
    "blue": {
      "foo": {
        "eggs": "delicious"
      }
    }
  }
}
```

But it's just overwriting based on the return value of `glob-all`, so you shouldn't depend on it.

## Output

Note that the [virtual module](https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention) generated has contents that conform to the [i18next resource format](https://www.i18next.com/misc/json-format).

While using the output with `import resources from 'virtual:i18next-loader'` will not be tree-shaken, it is possible to use the named outputs with a dynamic `import` for tree shaking/chunking optimizations. If you take advantage of this, please see #4 and take a moment to update this doc with more information.

**NOTE** as shown by the test output below, due to ES syntactical rules, we cannot use hyphenated lang codes. I'm open to ideas, but in the interim, affected lang codes are exported with the hyphen converted to underscore e.g. `zh-cn` has a named export of `zh_cn`. I noted that vite allows for tree-shaking of JSON files, perhaps that is worth looking at to consider how it might help us and inform our output?

```ts
export const en = {
  foo: { test: 'app foo.test en' },
  main: {
    test: 'app test en',
    sub: {
      slug: 'app sub.slug en',
      test: 'lib sub.test en',
      subsub: { slugslug: 'app sub.subsub.slugsub en', test: 'lib sub.subsub.test en' },
    },
  },
}
export const zh_cn = {
  foo: { test: 'app foo.test zh-cn' },
  main: {
    test: 'app test zh-cn',
    sub: {
      slug: 'app sub.slug zh-cn',
      test: 'lib sub.test zh-cn',
      subsub: { slugslug: 'app sub.subsub.slugsub zh-cn', test: 'lib sub.subsub.test zh-cn' },
    },
  },
}
const resources = {
  en,
  'zh-cn': zh_cn,
}
export default resources
```

## Vite typescript definitions

In order for the vite [virtual module](https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention) to be typechecked, you will need to a declaration. Below is an example of a common type file included in a project for vite:

```ts
// https://vitejs.dev/guide/api-hmr.html
interface ViteHotContext {
  readonly data: any

  // accept(): void
  accept(cb?: (mod: ModuleNamespace | undefined) => void): void
  accept(dep: string, cb: (mod: ModuleNamespace | undefined) => void): void
  accept(deps: readonly string[], cb: (mods: Array<ModuleNamespace | undefined>) => void): void

  dispose(cb: (data: any) => void): void
  decline(): void
  invalidate(): void

  // `InferCustomEventPayload` provides types for built-in Vite events
  on<T extends string>(event: T, cb: (payload: InferCustomEventPayload<T>) => void): void
  send<T extends string>(event: T, data?: InferCustomEventPayload<T>): void
}

// Allow for virtual module imports
// https://vitejs.dev/guide/api-plugin.html#virtual-modules-convention
declare module 'virtual:*'
```

## Credit

This was forked from [@alienfast/i18next-loader](https://github.com/alienfast/i18next-loader/), converted to be a vite plugin and improved. Thanks to the original authors and contributors.
